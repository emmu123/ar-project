<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real AR Server Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ar.js/2.2.2/aframe-ar.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            pointer-events: none;
        }

        .controls {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 0 0 15px 15px;
            backdrop-filter: blur(10px);
            pointer-events: all;
        }

        .ar-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            transition: transform 0.2s;
        }

        .ar-button:hover {
            transform: translateY(-2px);
        }

        .ar-button:active {
            transform: translateY(0);
        }

        .status-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            pointer-events: none;
            z-index: 1001;
        }

        .server-status {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 2000;
            max-width: 90%;
        }

        .instructions.hidden {
            display: none;
        }

        .marker-preview {
            width: 150px;
            height: 150px;
            border: 2px solid white;
            margin: 15px auto;
            background: white;
            background-image: 
                linear-gradient(45deg, #000 25%, transparent 25%), 
                linear-gradient(-45deg, #000 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #000 75%), 
                linear-gradient(-45deg, transparent 75%, #000 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 3000;
            display: none;
        }

        .hidden { display: none !important; }
        .ar-scene { 
            width: 100vw; 
            height: 100vh; 
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <!-- Error Message -->
    <div class="error-message" id="error-message"></div>

    <!-- Instructions Overlay -->
    <div class="instructions" id="instructions">
        <h2>üì± AR Server Monitor Ready!</h2>
        <p>To see your 3D servers in AR:</p>
        <ol style="text-align: left; max-width: 300px; margin: 0 auto;">
            <li>Print out this <strong>Hiro Marker</strong> below</li>
            <li>Place it on a flat surface</li>
            <li>Point your camera at the marker</li>
            <li>3D servers will appear above it!</li>
        </ol>
        
        <div class="marker-preview"></div>
        
        <p><small>Download marker: <a href="https://github.com/AR-js-org/AR.js/blob/master/data/images/hiro.png" target="_blank" style="color: #667eea;">Hiro Marker</a></small></p>
        
        <button class="ar-button" onclick="startAR()">üöÄ Start AR Camera</button>
        <button class="ar-button" onclick="showDemo()">üëÅÔ∏è Demo Mode</button>
    </div>

    <!-- UI Overlay -->
    <div class="ui-overlay hidden" id="ui-overlay">
        <div class="controls">
            <button class="ar-button" onclick="simulateLoad()">‚ö° Stress Test</button>
            <button class="ar-button" onclick="resetServers()">üîÑ Reset</button>
            <button class="ar-button" onclick="toggleStats()">üìä Stats</button>
            <button class="ar-button" onclick="exitAR()" style="background: #e74c3c;">‚ùå Exit</button>
        </div>
    </div>

    <!-- Status Panel -->
    <div class="status-panel hidden" id="status-panel">
        <div class="server-status">
            <span>üñ•Ô∏è Web Server Alpha:</span>
            <span id="server1-status">CPU: 45% | RAM: 67%</span>
        </div>
        <div class="server-status">
            <span>üíæ Database Beta:</span>
            <span id="server2-status">CPU: 72% | RAM: 84%</span>
        </div>
        <div class="server-status">
            <span>‚öôÔ∏è App Server Gamma:</span>
            <span id="server3-status">CPU: 89% | RAM: 91%</span>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 11px; opacity: 0.7;" id="ar-status">
            Point camera at Hiro marker to see 3D servers
        </div>
    </div>

    <!-- A-Frame AR Scene -->
    <a-scene 
        id="ar-scene"
        class="ar-scene hidden"
        embedded 
        arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3; trackingMethod: best; sourceWidth: 1280; sourceHeight: 960; displayWidth: 1280; displayHeight: 960;"
        vr-mode-ui="enabled: false"
        gesture-detector
        loading-screen="dotsColor: red; backgroundColor: black">
        
        <!-- Assets -->
        <a-assets>
            <!-- Server box mixin -->
            <a-mixin id="server-box"
                     geometry="primitive: box; width: 0.8; depth: 0.8"
                     material="transparent: true; opacity: 0.9"
                     animation__mouseenter="property: scale; to: 1.1 1.1 1.1; startEvents: mouseenter; dur: 200"
                     animation__mouseleave="property: scale; to: 1 1 1; startEvents: mouseleave; dur: 200"
                     class="clickable"
                     gesture-handler>
            </a-mixin>
            
            <!-- Ring mixin for activity indicators -->
            <a-mixin id="activity-ring"
                     geometry="primitive: torus; radius: 0.5; radiusTubular: 0.05"
                     material="transparent: true; opacity: 0.7">
            </a-mixin>
        </a-assets>

        <!-- Hiro Marker -->
        <a-marker preset="hiro" id="hiro-marker" raycaster="objects: .clickable" emitevents="true" cursor="fuse: false; rayOrigin: mouse;">
            <!-- Server 1: Web Server Alpha -->
            <a-entity id="server1-group" position="-1.5 0 0">
                <a-box id="server1-box"
                       mixin="server-box"
                       position="0 0.5 0"
                       height="1"
                       material="color: #00ff88"
                       text="value: Web Server\nAlpha\nCPU: 45%; align: center; color: white; position: 0 1.2 0; width: 4;">
                    <!-- Activity ring -->
                    <a-torus id="server1-ring"
                             mixin="activity-ring"
                             position="0 0.8 0"
                             material="color: #00ff88"
                             animation="property: rotation; to: 0 360 0; loop: true; dur: 4000">
                    </a-torus>
                    
                    <!-- CPU usage particles -->
                    <a-entity id="server1-particles"
                             position="0 1.5 0"
                             particle-system="preset: dust; particleCount: 20; color: #00ff88, #ffffff; size: 0.5">
                    </a-entity>
                </a-box>
            </a-entity>

            <!-- Server 2: Database Beta -->
            <a-entity id="server2-group" position="0 0 0">
                <a-box id="server2-box"
                       mixin="server-box"
                       position="0 0.75 0"
                       height="1.5"
                       material="color: #ffaa00"
                       text="value: Database\nBeta\nCPU: 72%; align: center; color: white; position: 0 1.4 0; width: 4;">
                    <!-- Activity ring -->
                    <a-torus id="server2-ring"
                             mixin="activity-ring"
                             position="0 1.0 0"
                             material="color: #ffaa00"
                             animation="property: rotation; to: 0 360 0; loop: true; dur: 2800">
                    </a-torus>
                    
                    <!-- CPU usage particles -->
                    <a-entity id="server2-particles"
                             position="0 1.8 0"
                             particle-system="preset: dust; particleCount: 35; color: #ffaa00, #ffffff; size: 0.7">
                    </a-entity>
                </a-box>
            </a-entity>

            <!-- Server 3: App Server Gamma -->
            <a-entity id="server3-group" position="1.5 0 0">
                <a-box id="server3-box"
                       mixin="server-box"
                       position="0 1 0"
                       height="2"
                       material="color: #ff4757"
                       text="value: App Server\nGamma\nCPU: 89%; align: center; color: white; position: 0 1.6 0; width: 4;">
                    <!-- Activity ring -->
                    <a-torus id="server3-ring"
                             mixin="activity-ring"
                             position="0 1.3 0"
                             material="color: #ff4757"
                             animation="property: rotation; to: 0 360 0; loop: true; dur: 1500">
                    </a-torus>
                    
                    <!-- CPU usage particles -->
                    <a-entity id="server3-particles"
                             position="0 2.3 0"
                             particle-system="preset: dust; particleCount: 50; color: #ff4757, #ffffff; size: 1">
                    </a-entity>
                </a-box>
            </a-entity>

            <!-- Network connections -->
            <a-entity id="network-connections">
                <!-- Connection lines between servers -->
                <a-cylinder position="-0.75 0.7 0" 
                           rotation="0 0 90"
                           radius="0.02"
                           height="1.5"
                           material="color: #00d4ff; opacity: 0.6; transparent: true"
                           animation="property: material.opacity; to: 0.2; dir: alternate; loop: true; dur: 2000">
                </a-cylinder>
                
                <a-cylinder position="0.75 0.85 0" 
                           rotation="0 0 90"
                           radius="0.02"
                           height="1.5"
                           material="color: #00d4ff; opacity: 0.6; transparent: true"
                           animation="property: material.opacity; to: 0.2; dir: alternate; loop: true; dur: 1800">
                </a-cylinder>
            </a-entity>

            <!-- Ambient lighting for better visibility -->
            <a-light type="ambient" color="#404040"></a-light>
            <a-light type="point" position="0 3 0" color="#ffffff" intensity="0.8"></a-light>
        </a-marker>

        <!-- Camera -->
        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // Server data
        let servers = [
            { name: "Web Server Alpha", cpu: 45, ram: 67, status: "healthy" },
            { name: "Database Beta", cpu: 72, ram: 84, status: "warning" },
            { name: "App Server Gamma", cpu: 89, ram: 91, status: "critical" }
        ];

        let arActive = false;
        let arScene = null;
        let updateInterval = null;

        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function startAR() {
            // Check for HTTPS (required for camera access in many browsers)
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                showError('Camera access requires HTTPS. Please use a secure connection.');
                return;
            }

            // Check camera support
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Camera not supported by this browser.');
                return;
            }

            // Request camera permission first
            navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 960 }
                } 
            })
            .then(function(stream) {
                console.log('Camera access granted');
                
                // Stop the stream since AR.js will handle it
                stream.getTracks().forEach(track => track.stop());
                
                // Initialize AR
                initializeAR();
            })
            .catch(function(err) {
                console.error('Camera access error:', err);
                let message = 'Camera access denied. ';
                
                if (err.name === 'NotAllowedError') {
                    message += 'Please allow camera access and try again.';
                } else if (err.name === 'NotFoundError') {
                    message += 'No camera found on device.';
                } else if (err.name === 'NotSupportedError') {
                    message += 'Camera not supported by browser.';
                } else {
                    message += `Error: ${err.message}`;
                }
                
                showError(message);
            });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('AR Server Dashboard loaded. Click "Start AR Camera" to begin!');
            
            // Check if we're on a secure connection
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                showError('‚ö†Ô∏è Camera requires HTTPS. Some features may not work on HTTP.');
            }
        });
        }

        function initializeAR() {
            try {
                // Hide instructions and show AR scene
                document.getElementById('instructions').classList.add('hidden');
                document.getElementById('ar-scene').classList.remove('hidden');
                document.getElementById('ui-overlay').classList.remove('hidden');
                document.getElementById('status-panel').classList.remove('hidden');
                
                arActive = true;
                arScene = document.getElementById('ar-scene');
                
                // Set up AR.js event listeners
                const marker = document.getElementById('hiro-marker');
                
                marker.addEventListener('markerFound', function() {
                    console.log('Marker found!');
                    document.getElementById('ar-status').textContent = 'Marker detected! Servers are visible.';
                });

                marker.addEventListener('markerLost', function() {
                    console.log('Marker lost!');
                    document.getElementById('ar-status').textContent = 'Point camera at Hiro marker to see 3D servers';
                });

                // Wait for scene to load
                arScene.addEventListener('loaded', function() {
                    console.log('AR Scene loaded successfully');
                    updateARServers();
                    updateInterval = setInterval(updateARServers, 3000);
                });

                // Handle AR.js errors
                arScene.addEventListener('arjs-video-loaded', function() {
                    console.log('AR video loaded');
                });

                arScene.addEventListener('camera-error', function(error) {
                    console.error('Camera error:', error);
                    showError('Failed to initialize camera. Please refresh and try again.');
                });

            } catch (error) {
                console.error('AR initialization error:', error);
                showError('Failed to start AR. Please refresh and try again.');
            }
        }

        function showDemo() {
            // Show demo without camera (for testing)
            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('ui-overlay').classList.remove('hidden');
            document.getElementById('status-panel').classList.remove('hidden');
            
            // Create a simple 3D demo without AR
            createDemoScene();
        }

        function createDemoScene() {
            const demoContainer = document.createElement('div');
            demoContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(135deg, #1e3c72, #2a5298);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                text-align: center;
                z-index: 500;
            `;
            
            demoContainer.innerHTML = `
                <div>
                    <h2>üñ•Ô∏è AR Demo Mode</h2>
                    <p>Server monitoring visualization ready!</p>
                    <div style="display: flex; gap: 20px; margin: 20px 0;">
                        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                            <div style="width: 60px; height: 80px; background: #00ff88; margin: 0 auto 10px;"></div>
                            <div>Web Server</div>
                            <div>CPU: 45%</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                            <div style="width: 60px; height: 100px; background: #ffaa00; margin: 0 auto 10px;"></div>
                            <div>Database</div>
                            <div>CPU: 72%</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                            <div style="width: 60px; height: 120px; background: #ff4757; margin: 0 auto 10px;"></div>
                            <div>App Server</div>
                            <div>CPU: 89%</div>
                        </div>
                    </div>
                    <p><small>In AR mode, these would be 3D objects floating above your marker!</small></p>
                </div>
            `;
            
            document.body.appendChild(demoContainer);
            arActive = true;
            updateInterval = setInterval(updateARServers, 3000);
        }

        function exitAR() {
            document.getElementById('instructions').classList.remove('hidden');
            document.getElementById('ar-scene').classList.add('hidden');
            document.getElementById('ui-overlay').classList.add('hidden');
            document.getElementById('status-panel').classList.add('hidden');
            
            // Remove demo container if it exists
            const demo = document.querySelector('div[style*="z-index: 500"]');
            if (demo) demo.remove();
            
            arActive = false;
            
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
        }

        function updateARServers() {
            if (!arActive) return;
            
            servers.forEach((server, index) => {
                const serverNum = index + 1;
                const serverBox = document.getElementById(`server${serverNum}-box`);
                const serverRing = document.getElementById(`server${serverNum}-ring`);
                const serverParticles = document.getElementById(`server${serverNum}-particles`);
                
                if (serverBox) {
                    // Update height based on CPU usage
                    const height = 0.5 + (server.cpu / 100) * 2;
                    const yPos = height / 2;
                    
                    serverBox.setAttribute('height', height);
                    serverBox.setAttribute('position', `0 ${yPos} 0`);
                    
                    // Update color based on CPU usage
                    let color = '#00ff88'; // Green
                    if (server.cpu > 60) color = '#ffaa00'; // Orange
                    if (server.cpu > 80) color = '#ff4757'; // Red
                    
                    serverBox.setAttribute('material', `color: ${color}`);
                    
                    // Update text
                    const text = `${server.name}\\nCPU: ${server.cpu}%\\nRAM: ${server.ram}%`;
                    serverBox.setAttribute('text', `value: ${text}; align: center; color: white; position: 0 ${height + 0.4} 0; width: 4;`);
                    
                    // Update ring
                    if (serverRing) {
                        serverRing.setAttribute('material', `color: ${color}`);
                        serverRing.setAttribute('position', `0 ${height + 0.3} 0`);
                        
                        // Faster rotation for higher CPU
                        const duration = Math.max(1000, 5000 - (server.cpu * 40));
                        serverRing.setAttribute('animation', `property: rotation; to: 0 360 0; loop: true; dur: ${duration}`);
                    }
                    
                    // Update particles
                    if (serverParticles) {
                        serverParticles.setAttribute('position', `0 ${height + 0.8} 0`);
                        const particleCount = Math.min(100, 20 + server.cpu);
                        serverParticles.setAttribute('particle-system', `preset: dust; particleCount: ${particleCount}; color: ${color}, #ffffff; size: ${0.3 + server.cpu/200}`);
                    }
                }
                
                // Update status panel
                const statusElement = document.getElementById(`server${serverNum}-status`);
                if (statusElement) {
                    statusElement.textContent = `CPU: ${server.cpu}% | RAM: ${server.ram}%`;
                }
            });
        }

        function simulateLoad() {
            servers.forEach(server => {
                server.cpu = Math.min(100, Math.max(0, server.cpu + Math.random() * 30 - 5));
                server.ram = Math.min(100, Math.max(0, server.ram + Math.random() * 20 - 5));
            });
            
            updateARServers();
        }

        function resetServers() {
            servers[0].cpu = 45; servers[0].ram = 67;
            servers[1].cpu = 72; servers[1].ram = 84;
            servers[2].cpu = 89; servers[2].ram = 91;
            
            updateARServers();
        }

        function toggleStats() {
            const panel = document.getElementById('status-panel');
            const currentDisplay = window.getComputedStyle(panel).display;
            panel.style.display = currentDisplay === 'none' ? 'block' : 'none';
        }

        // Add gesture handling for mobile
        AFRAME.registerComponent('gesture-handler', {
            schema: {
                enabled: { default: true },
                rotationFactor: { default: 5 },
                minScale: { default: 0.3 },
                maxScale: { default: 8 }
            },

            init: function () {
                this.handleScale = this.handleScale.bind(this);
                this.handleRotation = this.handleRotation.bind(this);

                this.isVisible = false;
                this.initialScale = this.el.object3D.scale.clone();
                this.scaleFactor = 1;

                this.el.sceneEl.addEventListener('markerFound', (e) => {
                    this.isVisible = true;
                });

                this.el.sceneEl.addEventListener('markerLost', (e) => {
                    this.isVisible = false;
                });
            },

            handleRotation: function (event) {
                if (this.isVisible) {
                    this.el.object3D.rotation.y += event.detail.rotationDelta.x * this.data.rotationFactor;
                    this.el.object3D.rotation.x += event.detail.rotationDelta.y * this.data.rotationFactor;
                }
            },

            handleScale: function (event) {
                if (this.isVisible) {
                    this.scaleFactor *= 1 + event.detail.spreadDelta / event.detail.startSpread;
                    this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
                    this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
                    this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
                    this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
                }
            }
        });

        // Register gesture detector
        AFRAME.registerComponent('gesture-detector', {
            schema: {
                element: { default: '' }
            },

            init: function () {
                this.targetElement = this.data.element && document.querySelector(this.data.element);

                if (!this.targetElement) {
                    this.targetElement = this.el;
                }

                this.internalState = {
                    previousState: null
                };

                this.emitGestureEvent = this.emitGestureEvent.bind(this);
                this.targetElement.addEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.addEventListener('touchend', this.emitGestureEvent);
                this.targetElement.addEventListener('touchmove', this.emitGestureEvent);
            },

            remove: function () {
                this.targetElement.removeEventListener('touchstart', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchend', this.emitGestureEvent);
                this.targetElement.removeEventListener('touchmove', this.emitGestureEvent);
            },

            emitGestureEvent: function (event) {
                const currentState = this.getTouchState(event);
                const previousState = this.internalState.previousState;

                const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
                const gestureEnded = previousState && !gestureContinues;
                const gestureStarted = currentState && !gestureContinues;

                if (gestureEnded) {
                    const eventName = this.getEventName(previousState.touchCount);
                    this.el.emit(eventName + 'ended', previousState);
                    this.internalState.previousState = null;
                }

                if (gestureStarted) {
                    currentState.startTime = performance.now();
                    currentState.startPosition = currentState.position;
                    currentState.startSpread = currentState.spread;
                    const eventName = this.getEventName(currentState.touchCount);
                    this.el.emit(eventName + 'started', currentState);
                }

                if (gestureContinues) {
                    const eventName = this.getEventName(currentState.touchCount);
                    if (currentState.touchCount == 1) {
                        this.el.emit(eventName + 'moved', currentState);
                    }
                    if (currentState.touchCount == 2) {
                        this.el.emit(eventName + 'moved', currentState);
                    }
                }

                this.internalState.previousState = currentState;
            },

            getTouchState: function (event) {
                if (event.touches.length === 0) {
                    return null;
                }

                const touchList = [];
                for (let i = 0; i < event.touches.length; i++) {
                    touchList.push(event.touches[i]);
                }

                const touchState = {
                    touchCount: touchList.length
                };

                const centerPositionRawX = touchList.reduce((sum, touch) => sum + touch.clientX, 0) / touchList.length;
                const centerPositionRawY = touchList.reduce((sum, touch) => sum + touch.clientY, 0) / touchList.length;

                touchState.positionRaw = { x: centerPositionRawX, y: centerPositionRawY };

                if (touchList.length >= 2) {
                    const spread = touchList.reduce((spread, touch) => {
                        return Math.max(spread, Math.sqrt(Math.pow(centerPositionRawX - touch.clientX, 2) + Math.pow(centerPositionRawY - touch.clientY, 2)));
                    }, 0);
                    touchState.spread = spread;
                }

                return touchState;
            },

            getEventName: function (touchCount) {
                const touchCountToEventName = {
                    1: 'onefinger',
                    2: 'twofinger',
                    3: 'threefinger',
                    4: 'fourfinger'
                };

                return touchCountToEventName[touchCount];
            }
      });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('AR Server Dashboard loaded. Click "Start AR Camera" to begin!');
            
            // Check if we're on a secure connection
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                showError('‚ö†Ô∏è Camera requires HTTPS. Some features may not work on HTTP.');
            }
            
            // Add click handlers for server boxes
            setTimeout(() => {
                const serverBoxes = document.querySelectorAll('[id^="server"][id$="-box"]');
                serverBoxes.forEach((box, index) => {
                    box.addEventListener('click', function() {
                        showServerDetails(index);
                    });
                });
            }, 1000);
        });

        function showServerDetails(serverIndex) {
            const server = servers[serverIndex];
            alert(`${server.name}\nCPU Usage: ${server.cpu}%\nRAM Usage: ${server.ram}%\nStatus: ${server.status}`);
        }

        // Real-time server monitoring simulation
        function startRealTimeMonitoring() {
            if (updateInterval) return;
            
            updateInterval = setInterval(() => {
                servers.forEach(server => {
                    // Simulate realistic server load fluctuations
                    const cpuChange = (Math.random() - 0.5) * 10;
                    const ramChange = (Math.random() - 0.5) * 5;
                    
                    server.cpu = Math.max(5, Math.min(95, server.cpu + cpuChange));
                    server.ram = Math.max(20, Math.min(98, server.ram + ramChange));
                    
                    // Update status based on CPU usage
                    if (server.cpu < 60) server.status = 'healthy';
                    else if (server.cpu < 80) server.status = 'warning';
                    else server.status = 'critical';
                });
                
                updateARServers();
            }, 2000);
        }

        function stopRealTimeMonitoring() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
        }

        // Network activity simulation
        function simulateNetworkActivity() {
            const connections = document.getElementById('network-connections');
            if (!connections) return;
            
            // Add pulsing data packets
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const packet = document.createElement('a-sphere');
                    packet.setAttribute('radius', '0.05');
                    packet.setAttribute('material', 'color: #00d4ff; emissive: #00d4ff');
                    packet.setAttribute('position', '-1.5 0.7 0');
                    packet.setAttribute('animation', 'property: position; to: 1.5 0.7 0; dur: 2000; easing: linear');
                    
                    connections.appendChild(packet);
                    
                    // Remove packet after animation
                    setTimeout(() => {
                        if (packet.parentNode) {
                            packet.parentNode.removeChild(packet);
                        }
                    }, 2100);
                }, i * 400);
            }
        }

        // Enhanced AR features
        function addAREnhancements() {
            if (!arActive) return;
            
            // Add holographic effect to servers
            const serverBoxes = document.querySelectorAll('[id^="server"][id$="-box"]');
            serverBoxes.forEach(box => {
                const hologram = document.createElement('a-cylinder');
                hologram.setAttribute('radius', '0.6');
                hologram.setAttribute('height', '0.1');
                hologram.setAttribute('material', 'color: #00d4ff; opacity: 0.2; transparent: true');
                hologram.setAttribute('position', '0 -0.6 0');
                hologram.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 8000');
                box.appendChild(hologram);
            });
            
            // Start network activity simulation
            setInterval(simulateNetworkActivity, 5000);
        }

        // Voice commands (experimental)
        function initVoiceCommands() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Speech recognition not supported');
                return;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.continuous = true;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            
            recognition.onresult = function(event) {
                const command = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
                console.log('Voice command:', command);
                
                if (command.includes('stress test') || command.includes('load test')) {
                    simulateLoad();
                } else if (command.includes('reset servers')) {
                    resetServers();
                } else if (command.includes('show stats')) {
                    toggleStats();
                } else if (command.includes('exit') || command.includes('stop')) {
                    exitAR();
                }
            };
            
            recognition.onerror = function(event) {
                console.log('Speech recognition error:', event.error);
            };
            
            // Start voice recognition when AR is active
            if (arActive) {
                recognition.start();
                console.log('Voice commands activated. Say "stress test", "reset servers", "show stats", or "exit"');
            }
        }

        // Performance monitoring
        function monitorPerformance() {
            let frameCount = 0;
            let lastTime = performance.now();
            
            function checkFPS() {
                frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - lastTime >= 1000) {
                    const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                    console.log('AR FPS:', fps);
                    
                    // Adjust quality based on performance
                    if (fps < 20 && arActive) {
                        console.log('Low FPS detected, reducing particle effects');
                        const particles = document.querySelectorAll('[particle-system]');
                        particles.forEach(p => {
                            const current = p.getAttribute('particle-system');
                            const reduced = current.replace(/particleCount: \d+/, 'particleCount: 10');
                            p.setAttribute('particle-system', reduced);
                        });
                    }
                    
                    frameCount = 0;
                    lastTime = currentTime;
                }
                
                if (arActive) {
                    requestAnimationFrame(checkFPS);
                }
            }
            
            if (arActive) {
                checkFPS();
            }
        }

        // Add AR quality settings
        function setARQuality(quality) {
            const arScene = document.getElementById('ar-scene');
            if (!arScene) return;
            
            let sourceWidth, sourceHeight, particleCount;
            
            switch(quality) {
                case 'low':
                    sourceWidth = 640;
                    sourceHeight = 480;
                    particleCount = 10;
                    break;
                case 'medium':
                    sourceWidth = 960;
                    sourceHeight = 720;
                    particleCount = 25;
                    break;
                case 'high':
                    sourceWidth = 1280;
                    sourceHeight = 960;
                    particleCount = 50;
                    break;
                default:
                    return;
            }
            
            // Update AR.js settings
            arScene.setAttribute('arjs', 
                `sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3; trackingMethod: best; sourceWidth: ${sourceWidth}; sourceHeight: ${sourceHeight}; displayWidth: ${sourceWidth}; displayHeight: ${sourceHeight};`
            );
            
            // Update particle systems
            const particles = document.querySelectorAll('[particle-system]');
            particles.forEach(p => {
                const current = p.getAttribute('particle-system');
                const updated = current.replace(/particleCount: \d+/, `particleCount: ${particleCount}`);
                p.setAttribute('particle-system', updated);
            });
            
            console.log(`AR quality set to ${quality}`);
        }

        // Auto-detect and set optimal quality
        function autoSetQuality() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const hasGoodGPU = navigator.hardwareConcurrency > 4;
            
            if (isMobile) {
                setARQuality('low');
            } else if (hasGoodGPU) {
                setARQuality('high');
            } else {
                setARQuality('medium');
            }
        }

        // Initialize everything when AR starts
        function enhancedStartAR() {
            startAR();
            setTimeout(() => {
                if (arActive) {
                    autoSetQuality();
                    addAREnhancements();
                    startRealTimeMonitoring();
                    monitorPerformance();
                    initVoiceCommands();
                }
            }, 2000);
        }

        // Replace the original startAR function
        window.originalStartAR = startAR;
        window.startAR = enhancedStartAR;

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (!arActive) return;
            
            switch(event.key) {
                case 's':
                case 'S':
                    simulateLoad();
                    break;
                case 'r':
                case 'R':
                    resetServers();
                    break;
                case 't':
                case 'T':
                    toggleStats();
                    break;
                case 'Escape':
                    exitAR();
                    break;
                case '1':
                    setARQuality('low');
                    break;
                case '2':
                    setARQuality('medium');
                    break;
                case '3':
                    setARQuality('high');
                    break;
            }
        });

        // Add fullscreen support
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Add double-tap to fullscreen on mobile
        let lastTap = 0;
        document.addEventListener('touchend', function(event) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            
            if (tapLength < 500 && tapLength > 0 && arActive) {
                toggleFullscreen();
                event.preventDefault();
            }
            lastTap = currentTime;
        });

        console.log('Enhanced AR Server Dashboard ready! üöÄ');
        console.log('Keyboard shortcuts: S=Stress Test, R=Reset, T=Toggle Stats, ESC=Exit, 1/2/3=Quality');
    </script>
</body>
</html>

        
